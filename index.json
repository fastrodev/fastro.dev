[{"content":"MongoDB sering dipakai untuk membuat dan menyimpan data di golang. Catatan ini berisi penjelasan se-simple mungkin tentang cara setup koneksi ke mongoDB dan membuat query sederhana.\nPersiapan Untuk bisa menyimpan data, harus kita siapkan dulu server mongodb-nya. Daftar aja secara gratis di mongodb atlas.\n  Ikuti saja panduan resmi dari mongodb untuk membuat cluster, hingga mendapatkan uri ke database semacam ini:\nmongodb+srv://admin:\u0026lt;password\u0026gt;@cluster0.xtwwu.mongodb.net   Jangan lupa untuk load sample dataset.\n  Awali app dengan go mod Bikin folder dan inisialisasi proyek dengan go mod.\nmkdir praktikum-mongodb cd praktikum-mongodb go mod init praktikum-mongodb Tambahkan mongodb driver Gunakan go get untuk menambahkan driver mongodb di golang.\ngo get go.mongodb.org/mongo-driver/mongo Buat fungsi main Buat fungsi main kosongan. Dan import driver mongodb.\npackage main import ( \u0026#34;go.mongodb.org/mongo-driver/bson\u0026#34; \u0026#34;go.mongodb.org/mongo-driver/mongo\u0026#34; \u0026#34;go.mongodb.org/mongo-driver/mongo/options\u0026#34; ) func main() {} Buat dan putus koneksi Di dalam fungsi main, tambahkan kode berikut:\nuri := \u0026#34;mongodb+srv://admin:admin@cluster0.u16np.mongodb.net\u0026#34; client, err := mongo.Connect(context.TODO(), options.Client().ApplyURI(uri)) if err != nil { panic(err) } defer func() { if err := client.Disconnect(context.TODO()); err != nil { panic(err) } }() Pada kode di atas, kita membuat koneksi ke mongodb server dengan method Connect.\nLalu kita memanggil defer agar ketika fungsi main selesai, koneksi ke mongodb diputus dengan method Disconnect.\n Sebagai catatan: fungsi yang dideklarasikan setelah defer tidak akan dijalankan hingga fungsi utama selesai. Informasi lanjut bisa diakses di sini: https://go.dev/tour/flowcontrol/12\n Query ke database Tambahkan kode berikut untuk membuat query sederhana.\ncoll := client.Database(\u0026#34;sample_mflix\u0026#34;).Collection(\u0026#34;movies\u0026#34;) title := \u0026#34;Back to the Future\u0026#34; var result bson.M err = coll.FindOne(context.TODO(), bson.D{{\u0026#34;title\u0026#34;, title}}).Decode(\u0026amp;result) if err == mongo.ErrNoDocuments { fmt.Printf(\u0026#34;No document was found with the title %s\\n\u0026#34;, title) return } if err != nil { panic(err) } jsonData, err := json.MarshalIndent(result, \u0026#34;\u0026#34;, \u0026#34; \u0026#34;) if err != nil { panic(err) } fmt.Printf(\u0026#34;%s\\n\u0026#34;, jsonData) Kode lengkapnya: lihat di sini\nPada kode di atas, kita membuat instance koleksi dari database sample_mflix dan koleksi movies.\nKita lalu membuat query untuk mendapatkan data melalui method FindOne dengan bson.D{{\u0026quot;title\u0026quot;, title}} sebagai filternya.\nHasilnya kemudian diolah dengan method MarshalIndent agar bisa ditampilkan dalam bentuk json.\nOya, kita selalu menangkap dan mengolah variabel err agar setiap terjadi kesalahan, kita bisa tahu detailnya.\nJalankan aplikasi Pergi ke terminal dan jalankan aplikasi\ngo run main.go Hasilnya seperti ini:\n{ \u0026#34;_id\u0026#34;: \u0026#34;573a1398f29313caabce9682\u0026#34;, \u0026#34;awards\u0026#34;: { \u0026#34;nominations\u0026#34;: 24, \u0026#34;text\u0026#34;: \u0026#34;Won 1 Oscar. Another 18 wins \\u0026 24 nominations.\u0026#34;, \u0026#34;wins\u0026#34;: 19 }, \u0026#34;cast\u0026#34;: [ \u0026#34;Michael J. Fox\u0026#34;, \u0026#34;Christopher Lloyd\u0026#34;, \u0026#34;Lea Thompson\u0026#34;, \u0026#34;Crispin Glover\u0026#34; ], \u0026#34;countries\u0026#34;: [ \u0026#34;USA\u0026#34; ], \u0026#34;directors\u0026#34;: [ \u0026#34;Robert Zemeckis\u0026#34; ], \u0026#34;fullplot\u0026#34;: \u0026#34;Marty McFly, a typical American teenager of the Eighties, is accidentally sent back to 1955 in a plutonium-powered DeLorean \\\u0026#34;time machine\\\u0026#34; invented by slightly mad scientist. During his often hysterical, always amazing trip back in time, Marty must make certain his teenage parents-to-be meet and fall in love - so he can get back to the future.\u0026#34;, \u0026#34;genres\u0026#34;: [ \u0026#34;Adventure\u0026#34;, \u0026#34;Comedy\u0026#34;, \u0026#34;Sci-Fi\u0026#34; ], \u0026#34;imdb\u0026#34;: { \u0026#34;id\u0026#34;: 88763, \u0026#34;rating\u0026#34;: 8.5, \u0026#34;votes\u0026#34;: 636511 }, \u0026#34;languages\u0026#34;: [ \u0026#34;English\u0026#34; ], \u0026#34;lastupdated\u0026#34;: \u0026#34;2015-09-12 00:29:36.890000000\u0026#34;, \u0026#34;metacritic\u0026#34;: 86, \u0026#34;num_mflix_comments\u0026#34;: 0, \u0026#34;plot\u0026#34;: \u0026#34;A young man is accidentally sent 30 years into the past in a time-traveling DeLorean invented by his friend, Dr. Emmett Brown, and must make sure his high-school-age parents unite in order to save his own existence.\u0026#34;, \u0026#34;poster\u0026#34;: \u0026#34;https://m.media-amazon.com/images/M/MV5BZmU0M2Y1OGUtZjIxNi00ZjBkLTg1MjgtOWIyNThiZWIwYjRiXkEyXkFqcGdeQXVyMTQxNzMzNDI@._V1_SY1000_SX677_AL_.jpg\u0026#34;, \u0026#34;rated\u0026#34;: \u0026#34;PG\u0026#34;, \u0026#34;released\u0026#34;: \u0026#34;1985-07-03T07:00:00+07:00\u0026#34;, \u0026#34;runtime\u0026#34;: 116, \u0026#34;title\u0026#34;: \u0026#34;Back to the Future\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;movie\u0026#34;, \u0026#34;writers\u0026#34;: [ \u0026#34;Robert Zemeckis\u0026#34;, \u0026#34;Bob Gale\u0026#34; ], \u0026#34;year\u0026#34;: 1985 } Praktikum Clone source code berikut https://github.com/fastrodev/praktikum-mongodb:\ngit clone https://github.com/fastrodev/praktikum-mongodb.git . Jalankan aplikasi seperti di atas.\n","permalink":"https://fastro.dev/posts/mongodb/","summary":"Cara setup koneksi ke mongodb dan membuat query sederhana","title":"Mongodb quickstart"},{"content":"Catatan ini berisi penjelasan se-simple mungkin tentang cara membuat aplikasi hello world di golang dari awal banget.\nDan sebagai persiapan:\n install go. siapkan terminal favoritmu.  Buat folder Buka terminal dan masuk ke sembarang direktori.\nmkdir app app bisa kita ganti dengan apapun.\nMasuk ke folder cd app Buat inisialisasi modul go mod init app Di sini, go mod init adalalah perintah untuk membuat module dari golang. Sedangkan app adalah nama modul.\nTapi sebenarnya kita bisa ganti dengan apapun.\nMisalnya: github.com/fastrodev/app\nBuat file entry point touch main.go Pada umumnya, file entry point di golang bernama main.go.\nTapi kita bisa ganti dengan apapun.\nMisalnya: app.go\nCopy dan paste Salin dan tempel kode berikut pada main.go.\npackage main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Hello, 世界\u0026#34;) } Jalankan aplikasi go run main.go Hasil Jika kode di atas kita jalankan, di terminal akan tercetak text seperti ini:\nHello, 世界 Praktikum Clone source code berikut https://github.com/fastrodev/praktikum-module:\ngit clone https://github.com/fastrodev/praktikum-module.git . Jalankan aplikasi seperti di atas.\n","permalink":"https://fastro.dev/posts/module/","summary":"Cara bikin aplikasi hello world di golang dari awal banget","title":"Module"},{"content":"Interface sering dipakai di golang. Catatan ini berisi penjelasan se-simple mungkin tentang interface dan cara menggunakannya.\nSignature Yang kita maksud dengan signature di sini adalah definisi input dan output sebuah method.\nMencakup:\n semua parameter dan tipe datanya return value dan tipe datanya  Nah, interface adalah tipe data yang berisi satu atau beberapa method signature.\nContoh:\npackage main type Box interface { Add() int Scale(s int) } Kode lengkapnya: lihat di sini\nPada kode diatas, kita buat sebuah interface bernama Box.\nDi dalamnya ada definisi:\n signature method Add() yang mengembalikan data bertipe int signature method Scale(s int) yang mengembalikan tipe data void.  Implementasi Karena interface hanya mendefinisikan signature saja, kita perlu membuat implementasinya.\nUntuk membuat implementasi Box interface, yang perlu kita lakukan adalah membuat sebuah struct:\ntype box struct { x, y int } Lalu menambahkan method yang signature-nya sama dengan apa yang telah didefinisikan di interface:\nfunc (b *box) Add() int { return b.x + b.y } func (b *box) Scale(s int) { b.x = b.x * s b.y = b.y * s } Kode lengkapnya: lihat di sini\nInstance Agar implementasi signature-signature di atas bisa digunakan, kita harus membuat instance dari struct tersebut.\nCaranya: buat sebuah fungsi yang return value-nya bertipe Box interface.\nfunc NewBox(x int, y int) Box { return \u0026amp;box{x, y} } Kita menyebut fungsi tersebut constructor.\nCara penggunaan Untuk memanggil method-method yang sudah di-implementasi di atas, kita tinggal membuat instance menggunakan constructor.\nSetalah instance-nya telah dibuat, kita bisa langsung memanggil method-method-nya.\nfunc main() { box := NewBox(1, 2) box.Scale(2) result := box.Add() fmt.Println(result) } Kode lengkapnya: lihat di sini\n","permalink":"https://fastro.dev/posts/interface/","summary":"Memahami interface di golang dan bagaimana cara menggunakannya","title":"Interface"},{"content":"Receiver sering sekali dipakai di golang. Catatan ini berisi penjelasan se-simple mungkin tentang receiver dan cara menggunakannya.\nTapi sebelum membahas receiver, kita akan singgung dulu hal yang sangat berkaitan: function dan method.\nFunction Ini adalah contoh sebuah fungsi di golang:\nfunc add(x int, y int) int { return x + y } Kode lengkapnya: lihat di sini.\nFungsinya sangat sederhana: hanya mengembalikan penjumlahan 2 integer.\nMethod Method sebenarnya adalah sebuah function juga. Hanya saja ia melekat pada sebuah struct.\nBerikut ini adalah contoh sebuah struct yang ditempelin oleh sebuah method add().\ntype box struct { x, y int } func (v box) add() int { return v.x + v.y } Receiver Receiver adalah argumen spesial yang digunakan sebuah struct untuk membuat fungsi agar melekat padanya.\nTanpa ada receiver, tak ada method.\nLihat kode method di atas, perhatikan bagian ini:\nfunc (v box) add() int { return v.x + v.y } Dalam hal ini, (v box), adalah receiver.\nDan dengan adanya receiver, method-method dapat diakses dengan cara seperti ini:\nfunc main() { v := box{3, 4} result := v.add() fmt.Println(result) } Kode lengkapnya: lihat di sini.\nPointer receivers Seperti telah kita ketahui, pointer dapat kita gunakan untuk mengakses alamat suatu variabel.\nApa yang terjadi jika pointer kita gunakan untuk receiver?\ntype box struct { x, y int } func (v *box) add() int { return v.x + v.y } Kode lengkapnya: lihat di sini.\nTernyata tidak ada yang terjadi.\nMari tambahkan satu fungsi yang bertujuan untuk mengubah variabel di dalam struct.\nKita tidak pakai pointer dulu, ya. Biar tahu apa bedanya.\ntype box struct { x, y int } func (v box) add() int { return v.x + v.y } func (v box) scale(s int) { v.x = v.x * s v.y = v.y * s } Kode lengkapnya: lihat di sini.\nTernyata tidak ada yang terjadi. Variabel x dan y dalam fungsi scale hanya menerima copi-an datanya saja. Nilai variabel dalam struct-nya sendiri tidak berubah.\nMari kita ganti spesial argumen di atas menggunakan pointer.\ntype box struct { x, y int } func (v *box) add() int { return v.x + v.y } func (v *box) scale(s int) { v.x = v.x * s v.y = v.y * s } Kode lengkapnya: lihat di sini.\nTernyata hasilnya berubah. Variabel x dan y dalam pointer telah sukses diganti oleh method scale.\nHal itu bisa terjadi karena yang diakses method tersebut adalah alamat variabel-variabel x dan y.\nSehingga saat alamat-alamat tersebut dikalikan 2, data-data di alamat tersebut akan ikut berubah.\n","permalink":"https://fastro.dev/posts/receiver/","summary":"Memahami receiver di golang dan bagaimana cara menggunakannya","title":"Receiver"},{"content":"Catatan ini berisi penjelasan se-simple mungkin tentang pointer, cara penggunaan, dan tampilan visual untuk memudahkan penggambaran di otak.\nLihat variabel-variable di kode berikut:\npackage main import \u0026#34;fmt\u0026#34; type People struct { Name string Age int } func main() { var age int = 4 var name string = \u0026#34;pram\u0026#34; var people = People{\u0026#34;Pram\u0026#34;, 4} } Untuk menggunakan variabel, kita tinggal memanggil saja namanya.\nContoh:\nfmt.Println(age) fmt.Println(name) fmt.Println(people.Age) fmt.Println(people.Name) Sebenarnya, setiap variable yang ditulis diatas, oleh komputer disimpan di memori dengan alamat tertentu.\nLihat gambar berikut:\nVariable age di address 0xc000018030\nVariable name di address 0xc000010230\nVariable people di address 0xc00000c030\nYang jadi pertanyaan:\n Bagaimana cara kita mendapatkan address variabel-variabel tersebut?  Cara mendapatkan address Gampang. Tambahkan saja simbol \u0026amp; (address operator) sebelum nama variabel.\nLihat kode berikut:\nfmt.Println(\u0026amp;age) fmt.Println(\u0026amp;name) fmt.Printf(\u0026#34;%p\\n\u0026#34;, \u0026amp;people) Yang jadi pertanyaan:\n Bagaimana cara kita menyimpan address?  Tipe data untuk menyimpan address Nah, inilah kegunaan pointer: tipe data yang digunakan untuk penyimpanan address dalam sebuah variabel.\nCara deklarasinya cukup menambahkan simbol * sebelum tipe data.\nLihat kode berikut:\nvar agePointer *int var namePointer *string var peoplePointer *People agePointer = \u0026amp;age namePointer = \u0026amp;name peoplePointer = \u0026amp;people Karena kecerdasan Golang, kode diatas bisa dipersingkat dengan cara berikut:\nagePointer := \u0026amp;age namePointer := \u0026amp;name peoplePointer := \u0026amp;people Jika langsung memanggil variabel-variabel pointer tersebut, yang kita dapatkan adalah memory address.\nPerhatikan kode berikut:\nfmt.Println(agePointer) fmt.Println(namePointer) fmt.Printf(\u0026#34;%p\\n\u0026#34;, peoplePointer) Hasilnya kurang lebih seperti ini:\n0xc000018030 0xc000010230 0xc00000c030 Lihat gambar berikut untuk mengetahui secara visual apa yang terjadi di memori:\nMendapatkan data dengan pointer Yang menarik adalah, kita bisa mendapatkan data \u0026ldquo;asal\u0026rdquo; hanya dengan menambahkan symbol * di depan nama variabel tersebut.\nLihat kode berikut:\nfmt.Println(*agePointer) fmt.Println(*namePointer) fmt.Println(*peoplePointer) Hasilnya:\n4 pram {Pram 4} Lihat gambar berikut:\nKode lengkapnya: lihat di sini\nKegunaan pointer Lihat kode berikut:\nvar people1 People var people2 People var people3 People people1 = People{\u0026#34;pram\u0026#34;,4} people2 = people1 people3 = people2 fmt.Println(people3) Di golang, secara default, pengkopian dilakukan secara passed by value. Oleh karena itu, semua variabel diatas akan dibuatkan space dan alamatnya di memori.\nBayangkan ada ribuan variabel seperti people, akan seperti apa kondisi memorinya? Tentu akan cepat penuh, bukan? Ini akan berakibat lambatnya pemrosesan.\nNah, karena pointer hanya menyimpan alamat memori, tentu saja ruang yang dipakai untuk menyimpan data tetap minimal.\nKredit dan referensi: Golang Basics - Pointers oleh Soham Kamani\n","permalink":"https://fastro.dev/posts/pointer/","summary":"Memahami pointer di golang dan bagaimana cara menggunakannya","title":"Pointer"}]