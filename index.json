[{"content":"Catatan ini berisi penjelasan se-simple mungkin tentang cara pembatalan (cancel) menggunakan context.WithTimeout di mongodb.\nPendahuluan Pada catatan sebelumnya, kita telah membuat simulasi penerapan context.WithTimeout secara sederhana untuk mengetahui cara kerjanya. Kali ini kita akan menerapkannya di mongodb.\nUbah repository type repository struct { coll *mongo.Collection timeout time.Duration } Kita tambahkan timeout agar bisa diakses di setiap method. Ini dilakukan agar tidak terjadi pengulangan deklarasi di setiap method.\nUbah instance repository func createBookRepository( ctx context.Context, timeout time.Duration, uri, db, col string, ) *repository { ctx, cancel := context.WithTimeout(ctx, timeout) defer cancel() client, err := mongo.Connect(ctx, options.Client().ApplyURI(uri)) if err != nil { panic(err) } return \u0026amp;repository{ coll: client.Database(db).Collection(col), timeout: timeout, } } Kita tambahkan argument baru: ctx dan timeout. Argumen tersebut masing-masing kita gunakan untuk inisialisasi ctx di fungsi dan injeksi timeout di repository.\nMasukkan context dan panggil cancel di setiap method func (r *repository) createBook(ctx context.Context, book Book) (*Book, error) { ctx, cancel := context.WithTimeout(ctx, r.timeout) defer cancel() res, err := r.coll.InsertOne(ctx, book) if err != nil { return nil, err } book.ID = res.InsertedID.(primitive.ObjectID) return \u0026amp;book, nil } Perhatikan, kita telah buat inisialiasi context.WithTimeout menggunakan timeout yang telah kita injeksi melalui repository.\nCara pemakaian Setelah signature fungsi dan method telah diubah, cara pemanggilannya juga perlu kita sesuaikan lagi:\nfunc main() { uri := \u0026#34;mongodb+srv://admin:admin@cluster0.xtwwu.mongodb.net\u0026#34; database := \u0026#34;myDB\u0026#34; collection := \u0026#34;favorite_books\u0026#34; ctx := context.Background() timeout := 10 * time.Second repo := createBookRepository(ctx, timeout, uri, database, collection) result, err := repo.createBook( ctx, Book{ Title: \u0026#34;Invisible Cities\u0026#34;, Author: \u0026#34;Italo Calvino\u0026#34;, Year: 1974, }, ) if err != nil { panic(err) } fmt.Printf(\u0026#34;Inserted document with _id: %v\\n\u0026#34;, result.ID) } Kode selengkapnya: lihat di sini\nPerhatikan bahwa inisialisasi context dan timeout cukup dilakukan sekali. Dan ia digunakan oleh semua fungsi dan method.\nJika kita jalankan, hasilnya:\nInserted document with _id: ObjectID(\u0026#34;61c8f92ba3e486cbdc3ee68b\u0026#34;) ","permalink":"https://fastro.dev/posts/cancel/","summary":"Memahami cara melakukan pembatalan menggunakan context.WithTimeout di mongodb","title":"Cancel"},{"content":"Catatan ini berisi penjelasan se-simple mungkin tentang context.WithTimeout di golang dan cara menggunakannya.\nPendahuluan Pada catatan sebelumnya:\n saat injeksi client di method createBookRepository saat pemanggilan collection di setiap method.  Ada satu argumen yang selalu kita isi dengan context.TODO(). Kalau kita teliti lagi, tipe argumen ini adalah context.Context.\nYang jadi pertanyaan: apa sih gunanya?\nSimulasi Dalam keadaan normal, internet stabil, jaringan bagus \u0026ndash; penggunaan Context seperti di atas tak ada masalah. Kembalian dari tiap method sudah berjalan seperti yang diharapkan.\nNamun bayangkan, jika koneksi internet tiba-tiba terganggu dan kita perlu melakukan pembatalan query (transaksi) karena itu.\nAgar lebih memahami cara kerjanya, kita akan buat satu fungsi untuk membuat simulasinya.\nFungsi ini punya 2 argumen. Argumen ke-1 menerima Context. Sedangkan argumen ke-2 menerima Duration.\nfunc task(ctx context.Context, taskTime time.Duration) { str := \u0026#34;\u0026#34; select { case \u0026lt;-ctx.Done(): str = `Aduh, udah timeout! padahal belum kelar.` fmt.Println(str) case \u0026lt;-time.After(taskTime): str = `Yes, mantap! kerjaan kelar.` fmt.Println(str) } } Argumen ke-1 digunakan untuk simulasi timeout. Sedang argumen ke-2 untuk simulasi berapa lama waktu yang diperlukan untuk menyelesaikan task tsb.\n Kode di atas menggunakan channel. Info selengkapnya bisa diakses di sini: https://go.dev/tour/concurrency/2\n Pekerjaan belum selesai, tapi sudah timeout func main() { fmt.Println(`Contoh: kerjaan belum selesai tapi sudah timeout:`) durasiKerjaan := 3 * time.Second // 3 detik \ttimeout := time.Second // 1 detik  ctx, cancel := context.WithTimeout(context.Background(), timeout) defer cancel() task(ctx, durasiKerjaan) } Kode selengkapnya: lihat di sini\nPada kode di atas, durasi task adalah 3 detik. Tapi timeout-nya lebih cepat.\nSehingga jika kode di atas kita jalankan, hasilnya:\nContoh: kerjaan belum selesai tapi sudah timeout: Aduh, udah timeout! padahal belum kelar. Pekerjaan sudah selesai duluan sebelum timeout func main() { fmt.Println(`Contoh: kerjaan sudah selesai duluan`) durasiKerjaan := time.Second // 1 detik \ttimeout := 3 * time.Second // 3 detik  ctx, cancel := context.WithTimeout(context.Background(), timeout) defer cancel() task(ctx, durasiKerjaan) } Kode selengkapnya: lihat di sini\nPada kode di atas, durasi kerjaan 1 detik. Sedangkan timeout 3 detik.\nSehingga jika kita jalankan, hasilnya:\nContoh: kerjaan sudah selesai duluan Yes, mantap! kerjaan kelar. Kesimpulan Kita bisa menggunakan context.WithTimeout jika ingin menambahkan pembatalan sebuah pekerjaan jika durasinya melebihi timeout.\n","permalink":"https://fastro.dev/posts/context/","summary":"Memahami context.WithTimeout di golang dan cara menggunakannya.","title":"Context with timeout"},{"content":"Marshal dan Unmarshal sering dipakai untuk mengolah data di golang. Catatan ini berisi penjelasan se-simple mungkin tentang marshal-unmarshal dan cara menggunakannya di mongodb.\nPendahuluan Pada catatan sebelumnya kita telah membuat crud. Kalau kita jalankan hasilnya, return dari method readBook masih seperti ini:\n\u0026amp;{\u0026lt;nil\u0026gt; 0xc00040e180 [] 0xc00013abd0} Karena return valuenya masih berupa pointer, yang tampil adalah alamat memori data itu berada.\nYang jadi pertanyaan: bagaimana cara kita menampilkan data yang lebih bisa dibaca (readable)?\nUbah signature Format return value yang menurut kita ideal adalah struct. Karena dengan struct, akan dengan mudah diubah ke format lain.\nfunc (r *repository) readBook(id interface{}) (*Book, error) { return nil, nil } Perhatikan, return valuenya berupa pointer struct agar yang diakses nanti adalah alamatnya.\nTambahkan query dan decode Kita tambahkan method Decode yang akan menyimpan hasilnya di variabel result.\nIngat, variabel ini bertipe bson.D agar bisa kita proses dengan fungsi Marshal.\nfunc (r *repository) readBook(id interface{}) (*Book, error) { filter := bson.M{\u0026#34;_id\u0026#34;: id} var result bson.D err := r.collection.FindOne(context.TODO(), filter).Decode(\u0026amp;result) if err != nil { return nil, err } fmt.Println(result) return nil, nil } Ada juga fungsi Println untuk menampilkan hasil method Decode. Jika kita jalankan, hasilnya kurang lebih seperti ini:\n[{_id ObjectID(\u0026#34;61c3b3e004b93f7df512035c\u0026#34;)} {title Invisible Cities} {author Italo Calvino} {year_published 1974}] Marshal Variabel result masih berbentuk bson. Sudah bisa dibaca, sih. Tapi formatnya masih belum sesuai dengan signature yang sudah kita tentukan.\nMarshal, berguna banget untuk mengubah result menjadi data yang bertipe byte[]. Tipe data terakhir inilah yang nantinya bisa diubah lagi menjadi struct.\nfunc (r *repository) readBook(id interface{}) (*Book, error) { filter := bson.M{\u0026#34;_id\u0026#34;: id} var result bson.D err := r.collection.FindOne(context.TODO(), filter).Decode(\u0026amp;result) if err != nil { return nil, err } docByte, err := bson.Marshal(result) if err != nil { return nil, err } fmt.Println(docByte) return nil, nil } Jika kita jalankan, docByte akan tampil seperti ini:\n[100 0 0 0 7 95 105 100 0 97 195 183 184 108 56 136 31 173 218 187 131 2 116 105 116 108 101 0 13 0 0 0 66 117 109 105 32 109 97 110 117 115 105 97 0 2 97 117 116 104 111 114 0 22 0 0 0 80 114 97 109 111 101 100 121 97 32 65 110 97 110 116 97 32 84 111 101 114 0 16 121 101 97 114 95 112 117 98 108 105 115 104 101 100 0 188 7 0 0 0] Unmarshal Setelah menjadi []byte, variabel docByte akan kita ubah menjadi struct Book. Fungsi yang berguna untuk tujuan itu adalah Unmarshal.\nfunc (r *repository) readBook(id interface{}) (*Book, error) { filter := bson.M{\u0026#34;_id\u0026#34;: id} var result bson.D err := r.collection.FindOne(context.TODO(), filter).Decode(\u0026amp;result) if err != nil { return nil, err } docByte, err := bson.Marshal(result) if err != nil { return nil, err } var book Book err = bson.Unmarshal(docByte, \u0026amp;book) if err != nil { return nil, err } fmt.Println(book) return \u0026amp;book, nil } Kalau kita jalankan, fungsi Println di atas hasilnya akan seperti ini:\n{ObjectID(\u0026#34;61c3b92981219573cfb48119\u0026#34;) Invisible Cities Italo Calvino 1974} Cara pemakaian Setelah signature telah kita ganti, cara pemakaian repository di fungsi main perlu kita sesuaikan.\nfunc main() { uri := \u0026#34;mongodb+srv://admin:admin@cluster0.xtwwu.mongodb.net\u0026#34; database := \u0026#34;myDB\u0026#34; collection := \u0026#34;favorite_books\u0026#34; repo := createBookRepository(uri, database, collection) result, err := repo.createBook(Book{ Title: \u0026#34;Invisible Cities\u0026#34;, Author: \u0026#34;Italo Calvino\u0026#34;, Year: 1974, }) if err != nil { panic(err) } fmt.Printf(\u0026#34;Inserted document with _id: %v\\n\u0026#34;, result.ID) book, err := repo.readBook(result.ID) if err != nil { panic(err) } fmt.Printf(\u0026#34;%v\\n\u0026#34;, *book) } Kode selengkapnya: lihat di sini\nKalau kita jalankan, hasilnya jadi seperti ini:\nInserted document with _id: ObjectID(\u0026#34;61c3da9bf49dd8380bb17ca0\u0026#34;) {ObjectID(\u0026#34;61c3da9bf49dd8380bb17ca0\u0026#34;) Invisible Cities Italo Calvino 1974} ","permalink":"https://fastro.dev/posts/marshal/","summary":"Memahami marshal dan unmarshal di golang dan cara menggunakannya di mongodb","title":"Marshal"},{"content":"Catatan ini berisi penjelasan se-simple mungkin tentang cara membuat CRUD di mongodb dengan repository.\nJika sebelumnya kita membuat koneksi dan query ke database dalam satu fungsi main, pada catatan ini kita akan melakukan beberapa refaktor:\n model untuk definisi data repository untuk akses data main untuk pemanggilan method  Membuat model Kita akan menyimpan data dengan struktur seperti ini:\ntype Book struct { ID primitive.ObjectID `bson:\u0026#34;_id,omitempty\u0026#34;` Title string `bson:\u0026#34;title,omitempty\u0026#34;` Author string `bson:\u0026#34;author,omitempty\u0026#34;` Year int `bson:\u0026#34;year_published,omitempty\u0026#34;` } Pada kode di atas, kita menggunakan anotasi bson.\n Info lanjut mengenai anotasi bson, bisa dilihat di sini: https://www.mongodb.com/blog/post/quick-start-golang\u0026ndash;mongodb\u0026ndash;modeling-documents-with-go-data-structures\n Membuat repository Repository ini nanti akan kita tempelin fungsi-fungsi crud.\ntype repository struct { collection *mongo.Collection } CRUD method Berikut ini adalah detail fungsi-fungsi CRUD yang menempel pada repository\nfunc (r *repository) createBook(book Book) (*mongo.InsertOneResult, error) { return r.collection.InsertOne(context.TODO(), book) } func (r *repository) readBook(id interface{}) *mongo.SingleResult { filter := bson.M{\u0026#34;_id\u0026#34;: id} return r.collection.FindOne(context.TODO(), filter) } func (r *repository) updateBook(id interface{}, book Book) (*mongo.UpdateResult, error) { filter := bson.M{\u0026#34;_id\u0026#34;: id} update := bson.M{\u0026#34;$set\u0026#34;: book} return r.collection.UpdateOne(context.TODO(), filter, update) } func (r *repository) deleteBook(id interface{}) (*mongo.DeleteResult, error) { filter := bson.M{\u0026#34;_id\u0026#34;: id} return r.collection.DeleteMany(context.TODO(), filter) } Repository instance Setelah itu, bikin satu fungsi untuk membuat instance repository:\nfunc createBookRepository(uri, db, col string) *repository { client, err := mongo.Connect(context.TODO(), options.Client().ApplyURI(uri)) if err != nil { panic(err) } return \u0026amp;repository{collection: client.Database(db).Collection(col)} } Pada kode di atas, property koleksi coll kita inject dengan instance client yang terhubung dengan server uri, database db, dan koleksi data col.\nVariabel-variabel di atas akan kita isi dari fungsi main.\n Catatan: perhatikan bahwa return dari fungsi createBookRepository ini berupa pointer sehingga hanya mengembalikan alamat di memori. Baca lagi catatan tentang pointer.\n Penggunaan repository Setelah repository kita buat, kita tinggal panggil method-method yang dibutuhkan.\nfunc main() { uri := \u0026#34;mongodb+srv://admin:admin@cluster0.xtwwu.mongodb.net\u0026#34; database := \u0026#34;myDB\u0026#34; collection := \u0026#34;favorite_books\u0026#34; repo := createBookRepository(uri, database, collection) result, err := repo.createBook(Book{ Title: \u0026#34;Invisible Cities\u0026#34;, Author: \u0026#34;Italo Calvino\u0026#34;, Year: 1974, }) if err != nil { panic(err) } fmt.Printf(\u0026#34;Inserted document with _id: %v\\n\u0026#34;, result.InsertedID) } Kode selengkapnya: lihat di sini\nJalankan aplikasi go run main.go Hasilnya:\nInserted document with _id: ObjectID(\u0026#34;61c2a3725e07b8c3ffb1e832\u0026#34;) Praktikum Clone source code berikut https://github.com/fastrodev/praktikum-repository:\ngit clone https://github.com/fastrodev/praktikum-repository . Download modul-modul\ngo mod tidy Jalankan aplikasi seperti di atas.\n","permalink":"https://fastro.dev/posts/repository/","summary":"Cara membuat mongodb crud (create read update delete) di golang dengan repository","title":"Repository"},{"content":"MongoDB sering dipakai untuk membuat dan menyimpan data di golang. Catatan ini berisi penjelasan se-simple mungkin tentang cara setup koneksi ke mongoDB dan membuat query sederhana.\nPersiapan Untuk bisa menyimpan data, harus kita siapkan dulu server mongodb-nya. Daftar aja secara gratis di mongodb atlas.\n  Ikuti saja panduan resmi dari mongodb untuk membuat cluster, hingga mendapatkan uri ke database semacam ini:\nmongodb+srv://admin:\u0026lt;password\u0026gt;@cluster0.xtwwu.mongodb.net   Jangan lupa untuk load sample dataset.\n  Awali app dengan go mod Bikin folder dan inisialisasi proyek dengan go mod.\nmkdir praktikum-mongodb cd praktikum-mongodb go mod init praktikum-mongodb Tambahkan mongodb driver Gunakan go get untuk menambahkan driver mongodb di golang.\ngo get go.mongodb.org/mongo-driver/mongo Buat fungsi main Buat fungsi main kosongan. Dan import driver mongodb.\npackage main import ( \u0026#34;go.mongodb.org/mongo-driver/bson\u0026#34; \u0026#34;go.mongodb.org/mongo-driver/mongo\u0026#34; \u0026#34;go.mongodb.org/mongo-driver/mongo/options\u0026#34; ) func main() {} Buat dan putus koneksi Di dalam fungsi main, tambahkan kode berikut:\nuri := \u0026#34;mongodb+srv://admin:admin@cluster0.u16np.mongodb.net\u0026#34; client, err := mongo.Connect(context.TODO(), options.Client().ApplyURI(uri)) if err != nil { panic(err) } defer func() { if err := client.Disconnect(context.TODO()); err != nil { panic(err) } }() Pada kode di atas, kita membuat koneksi ke mongodb server dengan method Connect.\nLalu kita memanggil defer agar ketika fungsi main selesai, koneksi ke mongodb diputus dengan method Disconnect.\n Sebagai catatan: fungsi yang dideklarasikan setelah defer tidak akan dijalankan hingga fungsi utama selesai. Informasi lanjut bisa diakses di sini: https://go.dev/tour/flowcontrol/12\n Query ke database Tambahkan kode berikut untuk membuat query sederhana.\ncoll := client.Database(\u0026#34;sample_mflix\u0026#34;).Collection(\u0026#34;movies\u0026#34;) title := \u0026#34;Back to the Future\u0026#34; var result bson.M err = coll.FindOne(context.TODO(), bson.D{{\u0026#34;title\u0026#34;, title}}).Decode(\u0026amp;result) if err == mongo.ErrNoDocuments { fmt.Printf(\u0026#34;No document was found with the title %s\\n\u0026#34;, title) return } if err != nil { panic(err) } jsonData, err := json.MarshalIndent(result, \u0026#34;\u0026#34;, \u0026#34; \u0026#34;) if err != nil { panic(err) } fmt.Printf(\u0026#34;%s\\n\u0026#34;, jsonData) Kode lengkapnya: lihat di sini\nPada kode di atas, kita membuat instance koleksi dari database sample_mflix dan koleksi movies.\nKita lalu membuat query untuk mendapatkan data melalui method FindOne dengan bson.D{{\u0026quot;title\u0026quot;, title}} sebagai filternya.\nHasilnya kemudian diolah dengan method MarshalIndent agar bisa ditampilkan dalam bentuk json.\nOya, kita selalu menangkap dan mengolah variabel err agar setiap terjadi kesalahan, kita bisa tahu detailnya.\nJalankan aplikasi Pergi ke terminal dan jalankan aplikasi\ngo run main.go Hasilnya seperti ini:\n{ \u0026#34;_id\u0026#34;: \u0026#34;573a1398f29313caabce9682\u0026#34;, \u0026#34;awards\u0026#34;: { \u0026#34;nominations\u0026#34;: 24, \u0026#34;text\u0026#34;: \u0026#34;Won 1 Oscar. Another 18 wins \\u0026 24 nominations.\u0026#34;, \u0026#34;wins\u0026#34;: 19 }, \u0026#34;cast\u0026#34;: [ \u0026#34;Michael J. Fox\u0026#34;, \u0026#34;Christopher Lloyd\u0026#34;, \u0026#34;Lea Thompson\u0026#34;, \u0026#34;Crispin Glover\u0026#34; ], \u0026#34;countries\u0026#34;: [ \u0026#34;USA\u0026#34; ], \u0026#34;directors\u0026#34;: [ \u0026#34;Robert Zemeckis\u0026#34; ], \u0026#34;fullplot\u0026#34;: \u0026#34;Marty McFly, a typical American teenager of the Eighties, is accidentally sent back to 1955 in a plutonium-powered DeLorean \\\u0026#34;time machine\\\u0026#34; invented by slightly mad scientist. During his often hysterical, always amazing trip back in time, Marty must make certain his teenage parents-to-be meet and fall in love - so he can get back to the future.\u0026#34;, \u0026#34;genres\u0026#34;: [ \u0026#34;Adventure\u0026#34;, \u0026#34;Comedy\u0026#34;, \u0026#34;Sci-Fi\u0026#34; ], \u0026#34;imdb\u0026#34;: { \u0026#34;id\u0026#34;: 88763, \u0026#34;rating\u0026#34;: 8.5, \u0026#34;votes\u0026#34;: 636511 }, \u0026#34;languages\u0026#34;: [ \u0026#34;English\u0026#34; ], \u0026#34;lastupdated\u0026#34;: \u0026#34;2015-09-12 00:29:36.890000000\u0026#34;, \u0026#34;metacritic\u0026#34;: 86, \u0026#34;num_mflix_comments\u0026#34;: 0, \u0026#34;plot\u0026#34;: \u0026#34;A young man is accidentally sent 30 years into the past in a time-traveling DeLorean invented by his friend, Dr. Emmett Brown, and must make sure his high-school-age parents unite in order to save his own existence.\u0026#34;, \u0026#34;poster\u0026#34;: \u0026#34;https://m.media-amazon.com/images/M/MV5BZmU0M2Y1OGUtZjIxNi00ZjBkLTg1MjgtOWIyNThiZWIwYjRiXkEyXkFqcGdeQXVyMTQxNzMzNDI@._V1_SY1000_SX677_AL_.jpg\u0026#34;, \u0026#34;rated\u0026#34;: \u0026#34;PG\u0026#34;, \u0026#34;released\u0026#34;: \u0026#34;1985-07-03T07:00:00+07:00\u0026#34;, \u0026#34;runtime\u0026#34;: 116, \u0026#34;title\u0026#34;: \u0026#34;Back to the Future\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;movie\u0026#34;, \u0026#34;writers\u0026#34;: [ \u0026#34;Robert Zemeckis\u0026#34;, \u0026#34;Bob Gale\u0026#34; ], \u0026#34;year\u0026#34;: 1985 } Praktikum Clone source code berikut https://github.com/fastrodev/praktikum-mongodb:\ngit clone https://github.com/fastrodev/praktikum-mongodb.git . Jalankan aplikasi seperti di atas.\n","permalink":"https://fastro.dev/posts/mongodb/","summary":"Cara setup koneksi ke mongodb dan membuat query sederhana","title":"Mongodb"},{"content":"Catatan ini berisi penjelasan se-simple mungkin tentang cara membuat aplikasi hello world di golang dari awal banget.\nPersiapan:\n install go. siapkan terminal favoritmu.  Buat folder Buka terminal dan masuk ke sembarang direktori.\nmkdir app app bisa kita ganti dengan apapun.\nMasuk ke folder cd app Buat inisialisasi modul go mod init app Di sini, go mod init adalalah perintah untuk membuat module dari golang. Sedangkan app adalah nama modul.\nTapi sebenarnya kita bisa ganti dengan apapun.\nMisalnya: github.com/fastrodev/app\nBuat file entry point touch main.go Pada umumnya, file entry point di golang bernama main.go.\nTapi kita bisa ganti dengan apapun.\nMisalnya: app.go\nCopy dan paste Salin dan tempel kode berikut pada main.go.\npackage main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Hello, 世界\u0026#34;) } Jalankan aplikasi go run main.go Hasil Jika kode di atas kita jalankan, di terminal akan tercetak text seperti ini:\nHello, 世界 Praktikum Clone source code berikut https://github.com/fastrodev/praktikum-module:\ngit clone https://github.com/fastrodev/praktikum-module.git . Jalankan aplikasi seperti di atas.\n","permalink":"https://fastro.dev/posts/module/","summary":"Cara bikin aplikasi hello world di golang dari awal banget","title":"Module"},{"content":"Interface sering dipakai di golang. Catatan ini berisi penjelasan se-simple mungkin tentang interface dan cara menggunakannya.\nSignature Yang kita maksud dengan signature di sini adalah definisi input dan output sebuah method.\nMencakup:\n semua parameter dan tipe datanya return value dan tipe datanya  Nah, interface adalah tipe data yang berisi satu atau beberapa method signature.\nContoh:\npackage main type Box interface { Add() int Scale(s int) } Kode lengkapnya: lihat di sini\nPada kode diatas, kita buat sebuah interface bernama Box.\nDi dalamnya ada definisi:\n signature method Add() yang mengembalikan data bertipe int signature method Scale(s int) yang mengembalikan tipe data void.  Implementasi Karena interface hanya mendefinisikan signature saja, kita perlu membuat implementasinya.\nUntuk membuat implementasi Box interface, yang perlu kita lakukan adalah membuat sebuah struct:\ntype box struct { x, y int } Lalu menambahkan method yang signature-nya sama dengan apa yang telah didefinisikan di interface:\nfunc (b *box) Add() int { return b.x + b.y } func (b *box) Scale(s int) { b.x = b.x * s b.y = b.y * s } Kode lengkapnya: lihat di sini\nInstance Agar implementasi signature-signature di atas bisa digunakan, kita harus membuat instance dari struct tersebut.\nCaranya: buat sebuah fungsi yang return value-nya bertipe Box interface.\nfunc NewBox(x int, y int) Box { return \u0026amp;box{x, y} } Kita menyebut fungsi tersebut constructor.\nCara penggunaan Untuk memanggil method-method yang sudah di-implementasi di atas, kita tinggal membuat instance menggunakan constructor.\nSetalah instance-nya telah dibuat, kita bisa langsung memanggil method-method-nya.\nfunc main() { box := NewBox(1, 2) box.Scale(2) result := box.Add() fmt.Println(result) } Kode lengkapnya: lihat di sini\n","permalink":"https://fastro.dev/posts/interface/","summary":"Memahami interface di golang dan bagaimana cara menggunakannya","title":"Interface"},{"content":"Receiver sering sekali dipakai di golang. Catatan ini berisi penjelasan se-simple mungkin tentang receiver dan cara menggunakannya.\nTapi sebelum membahas receiver, kita akan singgung dulu hal yang sangat berkaitan: function dan method.\nFunction Ini adalah contoh sebuah fungsi di golang:\nfunc add(x int, y int) int { return x + y } Kode lengkapnya: lihat di sini.\nFungsinya sangat sederhana: hanya mengembalikan penjumlahan 2 integer.\nMethod Method sebenarnya adalah sebuah function juga. Hanya saja ia melekat pada sebuah struct.\nBerikut ini adalah contoh sebuah struct yang ditempelin oleh sebuah method add().\ntype box struct { x, y int } func (v box) add() int { return v.x + v.y } Receiver Receiver adalah argumen spesial yang digunakan sebuah struct untuk membuat fungsi agar melekat padanya.\nTanpa ada receiver, tak ada method.\nLihat kode method di atas, perhatikan bagian ini:\nfunc (v box) add() int { return v.x + v.y } Dalam hal ini, (v box), adalah receiver.\nDan dengan adanya receiver, method-method dapat diakses dengan cara seperti ini:\nfunc main() { v := box{3, 4} result := v.add() fmt.Println(result) } Kode lengkapnya: lihat di sini.\nPointer receivers Seperti telah kita ketahui, pointer dapat kita gunakan untuk mengakses alamat suatu variabel.\nApa yang terjadi jika pointer kita gunakan untuk receiver?\ntype box struct { x, y int } func (v *box) add() int { return v.x + v.y } Kode lengkapnya: lihat di sini.\nTernyata tidak ada yang terjadi.\nMari tambahkan satu fungsi yang bertujuan untuk mengubah variabel di dalam struct.\nKita tidak pakai pointer dulu, ya. Biar tahu apa bedanya.\ntype box struct { x, y int } func (v box) add() int { return v.x + v.y } func (v box) scale(s int) { v.x = v.x * s v.y = v.y * s } Kode lengkapnya: lihat di sini.\nTernyata tidak ada yang terjadi. Variabel x dan y dalam fungsi scale hanya menerima copi-an datanya saja. Nilai variabel dalam struct-nya sendiri tidak berubah.\nMari kita ganti spesial argumen di atas menggunakan pointer.\ntype box struct { x, y int } func (v *box) add() int { return v.x + v.y } func (v *box) scale(s int) { v.x = v.x * s v.y = v.y * s } Kode lengkapnya: lihat di sini.\nTernyata hasilnya berubah. Variabel x dan y dalam pointer telah sukses diganti oleh method scale.\nHal itu bisa terjadi karena yang diakses method tersebut adalah alamat variabel-variabel x dan y.\nSehingga saat alamat-alamat tersebut dikalikan 2, data-data di alamat tersebut akan ikut berubah.\n","permalink":"https://fastro.dev/posts/receiver/","summary":"Memahami receiver di golang dan bagaimana cara menggunakannya","title":"Receiver"},{"content":"Catatan ini berisi penjelasan se-simple mungkin tentang pointer, cara penggunaan, dan tampilan visual untuk memudahkan penggambaran di otak.\nLihat variabel-variable di kode berikut:\npackage main import \u0026#34;fmt\u0026#34; type People struct { Name string Age int } func main() { var age int = 4 var name string = \u0026#34;pram\u0026#34; var people = People{\u0026#34;Pram\u0026#34;, 4} } Untuk menggunakan variabel, kita tinggal memanggil saja namanya.\nContoh:\nfmt.Println(age) fmt.Println(name) fmt.Println(people.Age) fmt.Println(people.Name) Sebenarnya, setiap variable yang ditulis diatas, oleh komputer disimpan di memori dengan alamat tertentu.\nLihat gambar berikut:\nVariable age di address 0xc000018030\nVariable name di address 0xc000010230\nVariable people di address 0xc00000c030\nYang jadi pertanyaan:\n Bagaimana cara kita mendapatkan address variabel-variabel tersebut?  Cara mendapatkan address Gampang. Tambahkan saja simbol \u0026amp; (address operator) sebelum nama variabel.\nLihat kode berikut:\nfmt.Println(\u0026amp;age) fmt.Println(\u0026amp;name) fmt.Printf(\u0026#34;%p\\n\u0026#34;, \u0026amp;people) Yang jadi pertanyaan:\n Bagaimana cara kita menyimpan address?  Tipe data untuk menyimpan address Nah, inilah kegunaan pointer: tipe data yang digunakan untuk penyimpanan address dalam sebuah variabel.\nCara deklarasinya cukup menambahkan simbol * sebelum tipe data.\nLihat kode berikut:\nvar agePointer *int var namePointer *string var peoplePointer *People agePointer = \u0026amp;age namePointer = \u0026amp;name peoplePointer = \u0026amp;people Karena kecerdasan Golang, kode diatas bisa dipersingkat dengan cara berikut:\nagePointer := \u0026amp;age namePointer := \u0026amp;name peoplePointer := \u0026amp;people Jika langsung memanggil variabel-variabel pointer tersebut, yang kita dapatkan adalah memory address.\nPerhatikan kode berikut:\nfmt.Println(agePointer) fmt.Println(namePointer) fmt.Printf(\u0026#34;%p\\n\u0026#34;, peoplePointer) Hasilnya kurang lebih seperti ini:\n0xc000018030 0xc000010230 0xc00000c030 Lihat gambar berikut untuk mengetahui secara visual apa yang terjadi di memori:\nMendapatkan data dengan pointer Yang menarik adalah, kita bisa mendapatkan data \u0026ldquo;asal\u0026rdquo; hanya dengan menambahkan symbol * di depan nama variabel tersebut.\nLihat kode berikut:\nfmt.Println(*agePointer) fmt.Println(*namePointer) fmt.Println(*peoplePointer) Hasilnya:\n4 pram {Pram 4} Lihat gambar berikut:\nKode lengkapnya: lihat di sini\nKegunaan pointer Lihat kode berikut:\nvar people1 People var people2 People var people3 People people1 = People{\u0026#34;pram\u0026#34;,4} people2 = people1 people3 = people2 fmt.Println(people3) Di golang, secara default, pengkopian dilakukan secara passed by value. Oleh karena itu, semua variabel diatas akan dibuatkan space dan alamatnya di memori.\nBayangkan ada ribuan variabel seperti people, akan seperti apa kondisi memorinya? Tentu akan cepat penuh, bukan? Ini akan berakibat lambatnya pemrosesan.\nNah, karena pointer hanya menyimpan alamat memori, tentu saja ruang yang dipakai untuk menyimpan data tetap minimal.\nKredit dan referensi: Golang Basics - Pointers oleh Soham Kamani\n","permalink":"https://fastro.dev/posts/pointer/","summary":"Memahami pointer di golang dan bagaimana cara menggunakannya","title":"Pointer"}]